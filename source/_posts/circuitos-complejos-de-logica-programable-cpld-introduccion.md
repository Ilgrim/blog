---
title: "Circuitos complejos de lógica programable - CPLD (Introducción)"
date: 2013-04-26 21:43:39
tags: 
---
<p style="text-align: justify;">Un <a href="http://es.wikipedia.org/wiki/CPLD" target="_blank">CPLD</a> (del inglés <em>Complex Programmable Logic Device</em>), es un chip que puede emular el comportamiento de miles de puertas lógicas interconectadas entre sí y junto con algunos bits de estado, registros o flip-flops –como quieras llamarlo– y cuenta con bastantes pines de entrada y salida, de forma que puedes implementar un circuito combinacional con algo de memoria (estados) bastante complejo (de ahí la C de <em>complex</em>)  Además es reprogramable, de forma que se puede configurar una y otra vez la función que emula el chip.</p>
<p style="text-align: justify;">Los CPLD son la evolución de lo que fueron los PLD, circuitos con el mismo funcionamiento pero más simples. Las PAL16V8 (PLD) que usábamos en la universidad corresponden a la mitad de una sola macrocelda de las 72 que tiene un XC9572XL, que es el CPLD que voy a usar dentro de poco.</p>
<p style="text-align: justify;">Los CPLD llevan ya bastantes años entre nosotros, pero no por ello se han quedado obsoletos. Sin embargo, más recientemente aparecieron las FPGA, que viene a ser lo mismo pero con esteroides, y eso sí, no tan rápidos. Una FPGA tiene cientos de pines en contraposición a las pocas decenas hasta el centenar que puede tener un CPLD, y de potencia de emulación ya ni hablemos: se pueden implementar procesadores enteros dentro de una FPGA.</p>
<p style="text-align: justify;">Centrándonos en los CPLD, contienen una matriz programable que configura la función que desempeña el chip. Esta matriz recibe por entradas los valores eléctricos de los pins y los valores anteriores del estado. Según esa entrada se generan los valores de la función para los pines de salida y los nuevos valores de los bits de estado, y así sucesivamente, sincronizado todo por un reloj que puede llegar a los 200 MHz.</p>
<p style="text-align: justify;">Los CPLD se programan desde el ordenador pero hace falta un dispositivo programador compatible JTAG. Cómo no, ha aparecido <a href="https://github.com/sowbug/JTAGWhisperer" target="_blank">un proyecto</a> que convierte el Arduino en un programador JTAG, esperemos que funcione, el tipo dice que le ha funcionado con el mismo CPLD que voy a usar yo.</p>
<p style="text-align: justify;">Veamos los CPLD que he elegido para hacer pruebas. Me he decantado por la marca Xilinx, que ofrece un entorno de programación o IDE con versión para Linux, y es de las casas más populares. Concretamente la familia XC9500. En realidad he comprado dos modelos de CPLD: el moderno XC9572XL, y el más antiguo pero que funciona a 5 voltios, XC9572 a secas.</p>
<p style="text-align: justify;">Bueno, las nomenclaturas son concretamente:</p>
<p style="text-align: justify;">XC9572XL VQG64 10I - éste tiene 64 pines, 52 de ellos configurables como entrada/salida. También es bastante rápido, con 10 ns de retraso, o 100 MHz de operación. Lo malo es que se ha de alimentar a 3.3V, aunque los pines son tolerantes a 5V y creo que podré programarlos con un Arduino. Me he pedido 5 de ellos por Ebay, a 3 euros me ha salido cada uno.</p>
<p style="text-align: justify;">XC957215PCG44C - éste es más antiguo, va a 5V y tiene menos pins (36 de E/S) me han costado 5 euros y pico cada uno, y me he comprado 3 de ellos hoy mismo en RS, aunque no tenían stock y hasta el día 2 no los enviarán.</p>
<p style="text-align: justify;">Ambos tienen el 72 en su nombre, que significa que tienen 72 macroceldas o bits de estado, de los cuales 52 están disponibles en pines de salida, en el modelo de 3.3V, y 36 están disponibles en el de 5V. 72 macroceldas es un término medio-bajo, hay CPLD en esta misma gama con 4 veces más, y los hay con la mitad.</p>
<p style="text-align: justify;"><a href="http://yombo.org/wp-content/uploads/2013/04/1-CPLD-Intro1.jpg"><img class="aligncenter size-large wp-image-587" alt="1 CPLD Intro" src="http://yombo.org/wp-content/uploads/2013/04/1-CPLD-Intro1-1024x358.jpg" width="625" height="218" /></a><a href="http://yombo.org/wp-content/uploads/2013/04/2-CPLD-Intro.jpg"><img class="aligncenter size-large wp-image-588" alt="2 CPLD Intro" src="http://yombo.org/wp-content/uploads/2013/04/2-CPLD-Intro-1024x809.jpg" width="625" height="493" /></a></p>
<p style="text-align: justify;">Ya veremos cómo se me da hacer una placa de pruebas para estos monstruitos y luego soldarlos... afortunadamente los otros (viejos) son encapsulados tipo PLCC, y se pueden meter en un zócalo con pines <em>through-hole</em> con espaciado estándar de 2.54 mm (compatible protoboard), así que seguro que haré las primeras pruebas con esos.</p>
<p style="text-align: justify;">Y... ¿Cómo se programan estos bichos? Pues es un arte entre la programación imperativa y el diseño de circuitos lógicos. El entorno de programación de Xilinx provee un editor gráfico para diseñar el comportamiento del CPLD como si estuvieras realmente construyendo un circuito. Añades lógica estándar, flip flops, y cualquier circuito clásico combinacional o con estado, y lo interconectas todo entre sí y a los pines de E/S como te convenga.</p>
<p style="text-align: justify;">Sin embargo yo prefiero la otra vertiente, que es programar el CPLD en un lenguaje de programación de toda la vida, es decir en ficheros de texto. En este caso hay dos opciones: Verilog o VHDL, yo prefiero éste último por ser más moderno y estructurado. Un programa en VHDL consta de una definición de las entradas y salidas del circuito, y una serie de bloques de código o <em>procesos</em> que son realmente eso, procesos que se ejecutan con concurrencia real dentro del CPLD (no como la concurrencia de los procesos en un ordenador, que es por compartición de tiempo). Los procesos se pueden comunicar entre sí como quieran usando  variables que representan las macroceldas o bits del CPLD. Puedes mezclar procesos puramente combinacionales con procesos que usen bits de estado, dividiendo así el CPLD en circuitos que hacen varias cosas para un mismo fin.</p>
<p style="text-align: justify;">¿Y para qué los voy a usar? Pues tengo tres usos posibles, dos de ellos usarán un chip de memoria además del CPLD. He comprado dos chips de 512KB de SRAM, a 12 ns (83 MHz de funcionamento)</p>
<p style="text-align: justify;">El primero que haré será lógicamente una placa de prueba, sin memoria, en un protoboard, con el reloj de sistema accionado por un botón, y mostrando resultados en LEDs. Luego pasaré a un reloj generado por un resonador, a algunos MHz. Cuando esto funcione añadiré un chip de memoria de 512 KB y un resonador de 80 MHz, para tener así un analizador lógico, que simplemente muestrea señales digitales a mucha frecuencia y las almacena en la memoria, para luego mostrarlas en el ordenador –se puede implementar incluso un puerto serie en el CPLD– Un analizador lógico es como un osciloscopio digital, pero que se puede programar para que empiece a muestrear o incluso que genere señales, cuando se da una cierta condición compleja.</p>
<p style="text-align: justify;">Cuando me funcione el analizador, lo podré usar para <em>debuguear</em> el segundo proyecto, de generar señal de vídeo VGA con uno de estos CPLD, una memoria de 512KB y un microcontrolador (la SRAM en este caso será la <em>videoram</em>) La señal VGA estándar tiene una frecuencia de píxel de 25.125 MHz, más que manejable por los XC9572 y por la memoria.</p>
<p style="text-align: justify;">Y el tercer proyecto podría ser hacer un interfaz con un Spectrum (por el bus de E/S) para controlar por ejemplo un robot a distancia...</p>
<p style="text-align: justify;">Nada más, hasta la próxima!</p>